<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="http://icbcbicc.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://icbcbicc.github.io/" rel="alternate" type="text/html" /><updated>2016-09-10T23:02:27+08:00</updated><id>http://icbcbicc.github.io/</id><title>icbcbicc&#39;s Blog</title><subtitle>Write your site description here. It will be used as your sites meta description as well!</subtitle><entry><title>Abnormal Event Detection at 150 FPS in MATLAB</title><link href="http://icbcbicc.github.io/2016/09/04/Abnormal-Event-Detection-at-150-FPS-in-MATLAB/" rel="alternate" type="text/html" title="Abnormal Event Detection at 150 FPS in MATLAB" /><published>2016-09-04T00:00:00+08:00</published><updated>2016-09-04T00:00:00+08:00</updated><id>http://icbcbicc.github.io/2016/09/04/Abnormal Event Detection at 150 FPS in MATLAB</id><content type="html" xml:base="http://icbcbicc.github.io/2016/09/04/Abnormal-Event-Detection-at-150-FPS-in-MATLAB/">&lt;h1 id=&quot;abnormal-event-detection-at-150-fps-in-matlab&quot;&gt;Abnormal Event Detection at 150 FPS in MATLAB&lt;/h1&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;h4 id=&quot;difficulties-in-detecting-abnormal-events-based-on-surveillance-videos&quot;&gt;Difficulties in detecting abnormal events based on surveillance videos&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Hard to list all possible negative samples&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;traditional-method&quot;&gt;Traditional method&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Normal patterns are learned from training&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And then the patterns are used to detect events deviated from this representation&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;other-methods&quot;&gt;Other methods&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Trajectories extracted from object-of-interest are used as normal patterns&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Learn normal low-level video feature distributions(exponential, multivariate Gaussian mixture, clustering)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Graph model normal event representations which use co-occurrence patterns&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sparsity-based model(not fast enough for realtime processing due to the inherently intensive computation to build sparse representation)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sparsity-based-abnormality-detection&quot;&gt;Sparsity Based Abnormality Detection&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Sparsity:  A general constraint to model normal event patterns as a linear combination of a set of basis atoms&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Computationally expensive&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;min\|x-D\beta\|^2_2 \qquad s.t. \qquad \|\beta\|_0 \le s&lt;/script&gt;

    &lt;p&gt;$ \beta $ : parse coefficients&lt;/p&gt;

    &lt;p&gt;$|x-D\beta|^2_2 $ :data fitting term&lt;/p&gt;

    &lt;p&gt;$|\beta|_0$ : sparsity regulization term&lt;/p&gt;

    &lt;p&gt;$s$ : parameter to control sparsity&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;abnormal pattern : large error result from $|x-D\beta|^2_2$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Efficiency problem&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Adopting $min|x-D\beta|^2_2$ is time-consuming :&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;ﬁnd the suitable basis vectors&lt;/strong&gt; (with scale $s$) from the dictionary (with scale $q$) to represent testing data $x$)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Search space is large &lt;strong&gt;( $(^q_s)$ different combinations )&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Our contribution&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Instead of coding sparsity by ﬁnding an $s$ basis combination from $D$ in $min|x-D\beta|^2_2$, we code it directly &lt;strong&gt;as a set of possible combinations of basis vectors&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;We only need to ﬁnd the most suitable combination by evaluating &lt;strong&gt;the small-scale least square error&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/img/3.JPG&quot; alt=&quot;Our testing architecture&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Freely selecting $s$ basis vectors from a total of $q$ vectors, the reconstructed structure could deviate from input due to the &lt;strong&gt;large freedom&lt;/strong&gt;. However, in our method, &lt;strong&gt;each combination ﬁnds its corresponding input data&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;It reaches 140∼150 FPS using a desktop with 3.4GHz CPU and 8G memory in MATLAB 2012.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;methods&quot;&gt;Methods&lt;/h2&gt;

&lt;h4 id=&quot;learning-combinations-on-training-data&quot;&gt;Learning Combinations on Training Data&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Preprocess&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Resize each frame into different scales as “&lt;a href=&quot;http://101.110.118.63/www3.ntu.edu.sg/home/jsyuan/index_files/papers/Cong-Yuan-CVPR11.pdf&quot;&gt;Sparse Reconstruction Cost for Abnormal Event Detection&lt;/a&gt;”&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Uniformly partition each layer to a set of non-overlapping patches. All patches have the same size&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Corresponding regions in 5 continuous frames are stacked together to form a spatial-temporal cube.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;/img/4.JPG&quot; alt=&quot;Resize&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;This pyramid involves &lt;strong&gt;local information&lt;/strong&gt; in ﬁne-scale layers and more &lt;strong&gt;global structures&lt;/strong&gt; in small-resolution ones.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;With the spatial-temporal cubes, we compute &lt;strong&gt;3D gradient features&lt;/strong&gt; on each of them following “&lt;a href=&quot;https://www.cs.drexel.edu/~kon/publication/LKratz_CVPR09.pdf&quot;&gt;Anomaly Detection in Extremely Crowded Scenes Using Spatio-Temporal Motion Pattern Models&lt;/a&gt;”&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Features are processed separately according to their spatial coordinates. &lt;strong&gt;Only features at the same spatial location in the video frames are used together&lt;/strong&gt; for training and testing.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Learning Combinations on Training Data&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Reconstruction Error&lt;/strong&gt;
 &lt;script type=&quot;math/tex&quot;&gt;t=min_{s,\gamma,\beta}\sum_{j=1}^n\sum_{i=1}^K\gamma_j^i\|x_j-S_i\beta_j^i\|_2^2 \quad s.t. \sum_{i=1}^K\gamma_j^i=1,\gamma_j^i=\{0,1\}&lt;/script&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Each $\gamma_j^i$ indicates whether or not the $i^{th}%$ combination $S_i$ is chosen for data $x_j$ and &lt;strong&gt;only one combination is selected&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;$K$ must be small enough&lt;/strong&gt; based on redundant surveillance video information because &lt;strong&gt;a very large $K$ could possibly make the reconstruction error $t$ always close to zero&lt;/strong&gt;, even for abnormal events&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Optimization for Training&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Problem : ** **Reducing $K$ could increase reconstruction errors $t$&lt;/strong&gt;. And it is not optimal to ﬁx $K$ as well,as content may vary among videos&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Solution : **  A maximum representation strategy. It **automatically ﬁnds $K$ while not wildly increasing the reconstruction error $t$&lt;/strong&gt;. In fact, error $t$ for each training feature is upper bounded in our method&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Updated function&lt;/strong&gt;
   &lt;script type=&quot;math/tex&quot;&gt;t_j=\sum_{i=1}^K\gamma_j^i \{ \|x_j-S_i\beta_j^i \|_2^2 -\lambda \} \le 0,\quad s.t. \sum_{i=1}^K\gamma_j^i=1,\gamma_j^i=\{0,1\}&lt;/script&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;$\lambda ： $  &lt;strong&gt;Reconstruction error upper bound&lt;/strong&gt; uniformly for all elements in $S$. If $t_j$ is smaller than $\lambda$, the coding result is with good quality&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Algorithm&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;In each pass, we update only one combination&lt;/strong&gt;, making it represent as many training data as possible&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;This process can &lt;strong&gt;quickly ﬁnd the dominating combinations encoding important and most common features&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Remaining training cube features that cannot be well represented by this combination are &lt;strong&gt;sent to the next round to gather residual maximum commonness&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;This process &lt;strong&gt;ends until all training data are computed and bounded&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The size of combination $K$ reﬂects how informative the training data are&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;In each pass, we &lt;strong&gt;solve the equation above by interatively update ${S_s^i,\beta}$ and $\lambda$&lt;/strong&gt;&lt;/p&gt;
        &lt;ol&gt;
          &lt;li&gt;&lt;strong&gt;Update ${S_s^i,\beta}$&lt;/strong&gt; :&lt;/li&gt;
        &lt;/ol&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;L(\beta,S_i)=\sum_{j \in \Omega_c}\gamma_j^i \{ \|x_j-S_i\beta_j^i \|_2^2 \}&lt;/script&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\beta_j^i=(S_i^TS_i)^{-1}S_i^Tx_j&lt;/script&gt;

        &lt;p&gt;(Optimize $\beta$ while ﬁxing $S_i$ for all $\gamma_j^i \neq 0$)&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;S_i=\prod[S_i-\delta_t\bigtriangledown_{S_i}L(\beta,S_i)]&lt;/script&gt;

        &lt;p&gt;( Using &lt;strong&gt;block-coordinate descent&lt;/strong&gt;( &lt;a href=&quot;http://www.jmlr.org/papers/volume11/mairal10a/mairal10a.pdf&quot;&gt;Online learning for matrix factorization and sparse coding&lt;/a&gt; and set $\delta = 1E-4$)&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;** Update $\gamma$ ** :&lt;/li&gt;
        &lt;/ol&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\gamma_j^i = \left\{
  \begin{aligned}
  1 \quad &amp; if \quad \|x_j-S_i\beta_j^i \|_2^2 &lt; \lambda ; \\
  0 \quad &amp; otherwise ;\\
  \end{aligned}
  \right . %]]&gt;&lt;/script&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/img/5.JPG&quot; alt=&quot;Algorithm 1&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;The algorithm is controlled by $\lambda$, Reducing it could lead to a larger $K$&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;Testing&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;With the learned sparse combinations $S = {S_1, …, S_K}$, in the testing phase with new data $x$, we checki f there exists a combination in $S$ ﬁtting the $\lambda$. It can be quickly achieved by checking the least square error for each $S_i$
  &lt;script type=&quot;math/tex&quot;&gt;$min_{\beta^i}\|x_j-S_i\beta_j^i \|_2^2 \quad \forall i= 1, ..., K&lt;/script&gt;$&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;**optimal solution : **&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{\beta^i}=(S_i^TS_i)^{-1}S_i^Tx&lt;/script&gt;

    &lt;ul&gt;
      &lt;li&gt;**Reconstruction error in $S_i$ : **
  &lt;script type=&quot;math/tex&quot;&gt;\|x_j-S_i\beta_j^i \|_2^2 = \|((S_i^TS_i)^{-1}S_i^T-I_p)x\|_2^2=\|R_ix\|_2^2&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/img/6.JPG&quot; alt=&quot;Algorithm 2&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;It is noted that the ﬁrst a few dominating combinations represent the largest number of normal event features.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Easy to parallel to achieve $O(1)$ complexity&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Average combination checking ratio $= \frac{The\  number\ of\ combinations\ checked}{The\ total\ number\ K}$&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Relation to Subspace Clustering&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;experiments&quot;&gt;Experiments&lt;/h2&gt;</content><author><name>icbcbicc</name></author><summary>Abnormal Event Detection at 150 FPS in MATLAB</summary></entry><entry><title>C++ Primer Note 1</title><link href="http://icbcbicc.github.io/2016/07/22/cprimer_note_1/" rel="alternate" type="text/html" title="C++ Primer Note 1" /><published>2016-07-22T00:00:00+08:00</published><updated>2016-07-22T00:00:00+08:00</updated><id>http://icbcbicc.github.io/2016/07/22/cprimer_note_1</id><content type="html" xml:base="http://icbcbicc.github.io/2016/07/22/cprimer_note_1/">&lt;h2 id=&quot;c-primer-4th-edition-notes-chapter-1--2&quot;&gt;C++ Primer 4th Edition Notes Chapter 1 &amp;amp; 2&lt;/h2&gt;

&lt;h3 id=&quot;chapter-1&quot;&gt;chapter 1&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;返回值必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型&lt;/li&gt;
  &lt;li&gt;返回值0表示&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数成功执行完毕，非0返回值的含义由各个OS自行定义&lt;/li&gt;
  &lt;li&gt;编译
    &lt;ul&gt;
      &lt;li&gt;Linux: &lt;code class=&quot;highlighter-rouge&quot;&gt;g++ a.cpp -o a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Windows: &lt;code class=&quot;highlighter-rouge&quot;&gt;cl -GX a.cpp&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++后缀与具体编译器有关：&lt;code class=&quot;highlighter-rouge&quot;&gt;.cc .ccx .cpp .cp .c&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看main的返回值
    &lt;ul&gt;
      &lt;li&gt;Linux: &lt;code class=&quot;highlighter-rouge&quot;&gt;echo $?&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Windows: &lt;code class=&quot;highlighter-rouge&quot;&gt;echo %ERRORLEVEL%&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;iostream
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cin&lt;/code&gt;: 标准输入&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cout&lt;/code&gt;: 标准输出&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cerr, clog&lt;/code&gt;: 标准错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Enter 2 nums:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;: 输出操作符，返回左操作数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;: 输入操作符，返回左操作数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endl&lt;/code&gt;: 操纵符，可以换行并且flush缓冲区&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;&lt;/code&gt;
  可以转换为&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std:cout &amp;lt;&amp;lt; v1+v2 &amp;lt;&amp;lt; std::endl;&lt;/code&gt;
可以转换为&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;读入未知数目的输入&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;输入文件结束符
    &lt;ul&gt;
      &lt;li&gt;Linux: &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+D&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Windows: &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+Z&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注释对&lt;code class=&quot;highlighter-rouge&quot;&gt;/* */&lt;/code&gt;不能嵌套&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;for(int count = 0;count&amp;lt;10;count++)&lt;/code&gt;循环中的&lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;在循环外不可访问(推荐使用，防止意外访问)&lt;/li&gt;
  &lt;li&gt;use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; &amp;gt;&lt;/code&gt; to include standard lib, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot; &quot;&lt;/code&gt; top include non-standard lib (personal lib)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-2&quot;&gt;chapter 2&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;2 kinds of character
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;: 8 bits&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wchar_t&lt;/code&gt;: 16 bits&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Do not use &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; as a computational type, it may results in some problems&lt;/li&gt;
  &lt;li&gt;In many circumstances, &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; runs much more faster than &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Usually, &lt;code class=&quot;highlighter-rouge&quot;&gt;long double&lt;/code&gt; is too time-consuming and not neccessary&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt; may leads to some wrap around false&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt; represent &lt;code class=&quot;highlighter-rouge&quot;&gt;signed *&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt; can be simply spelled as &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;All characters , including all unprintable characters, can be represented as &lt;code class=&quot;highlighter-rouge&quot;&gt;\obbb&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;\xddd&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;bbb&lt;/code&gt; are 3 octal numbers and &lt;code class=&quot;highlighter-rouge&quot;&gt;ddd&lt;/code&gt; are 3 hexadecimal numbers.&lt;/li&gt;
  &lt;li&gt;Every string in C++ will be added with an null character(&lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;) at the end of the string. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;A&quot;&lt;/code&gt; includes an &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;A&#39;&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;\0&lt;/code&gt;, but &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;A&#39;&lt;/code&gt; only contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;A&#39;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;wide char: &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;L&#39;&#39;A&#39;&lt;/code&gt;, wide string: &lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;L&#39;&quot;A&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Concatenate strings(they shoulde be the same kind of string): &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;A&quot; &quot;B&quot;&lt;/code&gt;. Join wide string and normal string may causes problpems(Undefinded operation)&lt;/li&gt;
  &lt;li&gt;Use &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; to split one line into two, but there is no need doing this if you wanna separate a string into more sub-strings. For example:&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;s&quot;&gt;&quot;asd&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;zxc&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;same&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;asd \
zxc&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;All characters(including space or tabs) after the &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; in the folowing line will be treated as part of the string, so the indent after &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt; may be incorrect&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化:
    &lt;ul&gt;
      &lt;li&gt;复制初始化 &lt;code class=&quot;highlighter-rouge&quot;&gt;int val = 1024;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;直接初始化 &lt;code class=&quot;highlighter-rouge&quot;&gt;int val(1024);&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;这两种初始化方法差别微妙，但是直接初始化语法更加灵活并且高效&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对内置类型来说，两种初始化几乎没有差别&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;对类型对象来说，有些初始化只能用直接初始化完成。有多个初始化式时不能使用复制初始化（即直接初始化需要多个参数时无法用复制初始化）。
例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;std::string a(4,&#39;9&#39;);&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;a = “9999”&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;在函数体外定义的内置类型会自动初始化为0，在函数内定义的内置函数不初始化&lt;/li&gt;
          &lt;li&gt;未初始化的变量事实上都有一个值&lt;/li&gt;
          &lt;li&gt;对于没有提供默认构造函数的类，必须在定义的时候显示地提供初始化式&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;声明与定义
    &lt;ul&gt;
      &lt;li&gt;定义：分配空间，指定初始值。一个程序中，一个变量有且只有一个定义（赋值可有多个）&lt;/li&gt;
      &lt;li&gt;声明：向程序表明变量的类型和名字，变量可声明多次。&lt;/li&gt;
      &lt;li&gt;定义属于声明，但声明不总是定义 
  例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;extern&lt;/code&gt;关键字可用于声明而不定义（也可用于声明并且定义），只有&lt;code class=&quot;highlighter-rouge&quot;&gt;extern&lt;/code&gt;位于函数外部时，才能含有初始化式（声明并且定义）&lt;/li&gt;
      &lt;li&gt;在多个文件中使用的变量都需要有与定义分离的声明。一个文件含有定义，使用这个变量的其他文件则包含声明&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;限定符：定义常量。因为常量定义后无法修改，因此定义时必须初始化&lt;/li&gt;
      &lt;li&gt;非&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;变量默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;extern&lt;/code&gt;，但要使&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;变量能在其他文件中访问，必须显示指定其为&lt;code class=&quot;highlighter-rouge&quot;&gt;extern const&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引用
    &lt;ul&gt;
      &lt;li&gt;引用是复合类型，是指用其他类型定义的类型。&lt;/li&gt;
      &lt;li&gt;不能定义引用类型的引用&lt;/li&gt;
      &lt;li&gt;引用必须用与该引用 相关联类型的对象（不能是常数） 来初始化（&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;引用除外）&lt;/li&gt;
      &lt;li&gt;引用只是一个别名，对引用的所有操作都是作用在该引用绑定的对象上&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;引用：可以读取但无法修改，可以绑定其他类型的对象（值可能会发生变化）或者常量&lt;/li&gt;
      &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;对象绑定到非&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;引用是非法的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt;定义类型的同义词
  -例如： &lt;code class=&quot;highlighter-rouge&quot;&gt;typedef int exam_score&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;exam_score&lt;/code&gt;就可以当做&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;枚举(&lt;code class=&quot;highlighter-rouge&quot;&gt;enumeration&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;关键字: &lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;enum modes {input,output,append}&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;modes&lt;/code&gt;式枚举类型名称。默认第一个枚举成员&lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;的值为1，后面每个枚举成员的值比前面一个大1。&lt;/li&gt;
      &lt;li&gt;可以定义枚举成员的初值，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;enum modes {input=2,output,append}&lt;/code&gt;，其后每个成员依次加1&lt;/li&gt;
      &lt;li&gt;枚举成员的值可以不唯一。但都是常量，无法修改&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt;定义了一个新的类型，可以定义和初始化其中的枚举成员&lt;br /&gt;
  例如： &lt;code class=&quot;highlighter-rouge&quot;&gt;modes delete = append&lt;/code&gt;&lt;br /&gt;
  但只能用枚举成员或者同一枚举类型的其他对象来初始化，不能使用常数&lt;br /&gt;
  例如： &lt;code class=&quot;highlighter-rouge&quot;&gt;modes delete = 3&lt;/code&gt;是错误的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;唯一区别在于默认访问级别
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;：每一个成员都默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;：每一个成员都默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;头文件一般包含
    &lt;ul&gt;
      &lt;li&gt;类的定义&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extern&lt;/code&gt;变量的声明&lt;/li&gt;
      &lt;li&gt;函数的声明&lt;/li&gt;
      &lt;li&gt;由常量初始化的&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;变量&lt;/li&gt;
      &lt;li&gt;例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;extern int a = 10;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;double b;&lt;/code&gt;都属于定义，不应该出现在头文件中（头文件包含在多个源文件中，直接定义容易产生多重定义错误）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译时将&lt;code class=&quot;highlighter-rouge&quot;&gt;#include&amp;lt;头文件&amp;gt;&lt;/code&gt;替换为头文件的内容，因此头文件内的变量声明不用&lt;code class=&quot;highlighter-rouge&quot;&gt;extern&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设计头文件时应该保证多次包含同一头文件不会引起多次定义，可以通过使用 头文件保护符 让头文件安全&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;预处理器变量
    &lt;ul&gt;
      &lt;li&gt;通常全部大写，在程序中必须唯一&lt;/li&gt;
      &lt;li&gt;使用类名来命名预处理器变量可以避免预处理器变量重名&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt;用于指定一个名字为预处理器变量&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifndef&lt;/code&gt;用于检测指定的预处理器变量是否未定义，如果未定义，则处理其后所有指令直到&lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#define&lt;/code&gt;写在&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifndef&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt;之间即可保证头文件不被多次包含
&lt;br /&gt;例如：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef TAG
#define TAG
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>icbcbicc</name></author><category term="C++" /><summary>C++ Primer 4th Edition Notes Chapter 1 &amp;amp; 2</summary></entry><entry><title>Machine Learning (Zhihua Zhou) Notes 01</title><link href="http://icbcbicc.github.io/2016/07/20/machine_learning_zhihua_zhou_notes_01/" rel="alternate" type="text/html" title="Machine Learning (Zhihua Zhou) Notes 01" /><published>2016-07-20T00:00:00+08:00</published><updated>2016-07-20T00:00:00+08:00</updated><id>http://icbcbicc.github.io/2016/07/20/machine_learning_zhihua_zhou_notes_01</id><content type="html" xml:base="http://icbcbicc.github.io/2016/07/20/machine_learning_zhihua_zhou_notes_01/">&lt;h1 id=&quot;machinelearningzhihuazhounotes-01&quot;&gt;Machine_Learning_Zhihua_Zhou_Notes-01&lt;/h1&gt;</content><author><name>icbcbicc</name></author><category term="machine learning" /><summary></summary></entry><entry><title>Learning Spatiotemporal Features with 3D CNN</title><link href="http://icbcbicc.github.io/2016/07/13/Learning-Spatiotemporal-Features-with-3D-CNN/" rel="alternate" type="text/html" title="Learning Spatiotemporal Features with 3D CNN" /><published>2016-07-13T00:00:00+08:00</published><updated>2016-07-13T00:00:00+08:00</updated><id>http://icbcbicc.github.io/2016/07/13/Learning Spatiotemporal Features with 3D CNN</id><content type="html" xml:base="http://icbcbicc.github.io/2016/07/13/Learning-Spatiotemporal-Features-with-3D-CNN/">&lt;h1 id=&quot;learning-spatiotemporal-features-with-3d-cnn&quot;&gt;Learning Spatiotemporal Features with 3D CNN&lt;/h1&gt;
&lt;p&gt;July 10, 2016 12:56 PM&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;1. Introduction&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;3 × 3 × 3 convolution kernel for all layers to work best.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;related-work&quot;&gt;2. Related Work&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Takes full video frames as inputs&lt;/li&gt;
  &lt;li&gt;Doesn’t rely on any preprocessing&lt;/li&gt;
  &lt;li&gt;3D convolutions and 3D pooling&lt;/li&gt;
  &lt;li&gt;Gradually pooling space and time information and building deeper networks achieves best result&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;learning-features-with-3d-convnets&quot;&gt;3. Learning Features with 3D ConvNets&lt;/h2&gt;

&lt;h4 id=&quot;d-convolution-and-pooling&quot;&gt;3D convolution and pooling&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;2D convolution (lose temporal information)&lt;/li&gt;
  &lt;li&gt;2D convolution on mutiple frames (lose temporal information)&lt;/li&gt;
  &lt;li&gt;3D convolution (preserves temporal information)&lt;/li&gt;
  &lt;li&gt;Small receptive fields of 3×3 conv kernels with deeper architectures yield best result&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;common-network-settings-ucf101-data-set&quot;&gt;Common network settings: UCF101 data set&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;All frames are resized to 128×171&lt;/li&gt;
  &lt;li&gt;Split into non-overlapped 16-frame clips&lt;/li&gt;
  &lt;li&gt;Input dimentions: 3×16×128×171 (channels,length in number of frames,height,iwdth)&lt;/li&gt;
  &lt;li&gt;5 conv layers and 5 pooling layers&lt;/li&gt;
  &lt;li&gt;2 fully-connected layers and a softmax loss layer&lt;/li&gt;
  &lt;li&gt;All convolution kernels have a kernel temporal depth&lt;/li&gt;
  &lt;li&gt;Mini-batches: 30 clips&lt;/li&gt;
  &lt;li&gt;Learning rate is divided by 10 after every 4 epochs&lt;/li&gt;
  &lt;li&gt;Training is stopped after 16 epochs&lt;/li&gt;
  &lt;li&gt;Not to merge the temporal signal too early&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;varying-network-architectures&quot;&gt;Varying network architectures&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Only vary kernal temporal depth d of the convolution layers&lt;/li&gt;
  &lt;li&gt;depth=1 :2D&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Different kernal temporal depth
&lt;img src=&quot;/img/1.JPG&quot; alt=&quot;kernal temporal depth&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;homogeneous setting with convolution kernals of depth = 3 is the best option&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spatiotemporal-feature-learning&quot;&gt;Spatiotemporal feature learning&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C3D architecture
&lt;img src=&quot;/img/2.JPG&quot; alt=&quot;C3D architecture&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;All 3D conv layers: 3×3×3 with stride 1×1×1&lt;/li&gt;
  &lt;li&gt;All 3D pooling layers: 2×2×2 with stride 2×2×2 except for pool-1 (both kernel size and stride: 1×2×2)&lt;/li&gt;
  &lt;li&gt;Deconvolution method to visualize the features
&lt;a href=&quot;http://link.springer.com/content/pdf/10.1007%2F978-3-319-10590-1_53.pdf&quot;&gt;M. Zeiler and R. Fergus. Visualizing and understanding convolutional networks. In ECCV, 2014. 5, 6, 9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>icbcbicc</name></author><category term="machine learning" /><category term="deep learning" /><category term="CNN" /><category term="caffe" /><summary>Learning Spatiotemporal Features with 3D CNN
July 10, 2016 12:56 PM</summary></entry><entry><title>This is my first Blog</title><link href="http://icbcbicc.github.io/2016/07/04/first-test/" rel="alternate" type="text/html" title="This is my first Blog" /><published>2016-07-04T00:00:00+08:00</published><updated>2016-07-04T00:00:00+08:00</updated><id>http://icbcbicc.github.io/2016/07/04/first-test</id><content type="html" xml:base="http://icbcbicc.github.io/2016/07/04/first-test/">&lt;h1 id=&quot;first-line&quot;&gt;First line&lt;/h1&gt;

&lt;h3 id=&quot;second-line&quot;&gt;Second line&lt;/h3&gt;</content><author><name>icbcbicc</name></author><summary>First line</summary></entry></feed>
